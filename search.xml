<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[来讲讲订阅发布与观察者模式]]></title>
    <url>%2F2020%2F03%2F15%2F%E6%9D%A5%E8%AE%B2%E8%AE%B2%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E4%B8%8E%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[这两天常被人问到你知道什么是观察者模式吗？ 什么是订阅发布模式？ 两者又有什么区别？我细细一想，还真是被问到了，脑子里开始绕了起来。 借着这个疑问，就又复习了一下。 订阅发布模式 个人理解， 订阅发布模式其实就是像我们去报亭里订阅一份报纸，或者是在微信上订阅公众号，就是我通过报亭订阅了这个事件，然后一旦有这个事件的时 候，报亭呢，就会发布，我就会收到这个事件了。报亭—就是订阅发布的中间人。这个是和观察者模式最大的区别。多说无益，代码来展示一下。 123456789101112131415161718192021222324252627282930 var pubsub = (() =&gt; &#123; var events = &#123;&#125;; function subscripe(eventName, fn) &#123; if (!events[eventName]) &#123; events[eventName] = [] &#125; events[eventName] = fn; &#125; function publish(eventName, ...args) &#123; if (!events[eventName]) &#123; // 说明没有订阅这个事件 return; &#125; for (let fn of events[eventName]) &#123; fn(...args); &#125; &#125; return &#123; subscripe, publish &#125; &#125;)()// 使用pubsub.subscribe('aa', (name, age) =&gt; &#123; console.log(`I am $&#123;name&#125;, my age is $&#123;age&#125;`)&#125;)pubsub.publish('aa', 'zj', 20)// =&gt; I am zj, my age is 20;// 因为事件一发布，订阅事件就收到了，然后执行了打印方法。 观察者模式比如我家里有一个摄像头，然后家人都有权限查看。 那么家人就是观察者， 家里的情况是被观察者。 这个就是一个直接的一对多关系。 直接进行观察的。 就好比是拍卖一个东西， 好多人都在看着，那么这个东西是被观察者， 在座的参加拍卖的都是观察者。 再举个例子，比如直播间。 主播是被观察者， 观众是观察者。 那么主播说了什么的时候， 观察者一直在观察者， 主播提到谁的名字，所有观察者都可以看到。 12345678910111213141516171819202122232425262728293031323334353637// 举个例子，subject 比如是主播class Subject &#123; constructor() &#123; this.name = ''; this.people = []; &#125; attatch(person) &#123; this.people.push(person); &#125; getName() &#123; return this.name; &#125; setName(name) &#123; this.name = name; this.notifyAll(); &#125; notifyAll() &#123; this.people.forEach((person) =&gt; &#123; person.update(); &#125;) &#125;&#125;class Observer &#123; constructor(name, subject) &#123; this.name = name; this.subject = subject; this.subject.attatch(this); &#125; update() &#123; console.log(`$&#123;this.name&#125; heard $&#123;this.subject.getName()&#125;`) &#125;&#125;var s = new Subject()var a1 = new Observer('a1', s)var a2 = new Observer('a2', s)s.setName('zj') 二者区别 订阅发布可以通过一个中间人来完成， 观察者模式时观察者和被观察者直接沟通来完成。 订阅发布是通过中间人来订阅一个事件，如果有这个事件的话，则发布后，订阅人就会执行。 而观察者模式不同，只要是观察者，那么被观察者一有 动静，所有的观察者都会得到更新。]]></content>
      <tags>
        <tag>‘设计模式’</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa2使用jsonWebToken（jwt）进行鉴权]]></title>
    <url>%2F2020%2F03%2F08%2Fkoa2%E4%BD%BF%E7%94%A8jsonWebToken%EF%BC%88jwt%EF%BC%89%E8%BF%9B%E8%A1%8C%E9%89%B4%E6%9D%83%2F</url>
    <content type="text"><![CDATA[最近使用koa2的时候，想到使用jwt进行 鉴权。于是就使用了。下面是具体引用步骤 安装依赖包 npm install jsonwebtoken 和 npm install koa-jwt. jsonwebtoken是当下最通用 的服务端与客户端鉴权方式。即： 客户端输入账号密码，请求服务端后，服务端通过jsonwebtoken 生成一个token字符串，返回给客户端，此后，客户端与服务器的会话都由这个token 来保持, 这 个生成的token会对应客户端传来的账号和密码。每次客户端携带这个token来进行身份识别。 使用kow-jwt中间件 在app.js中引入 kow-jwt。然后设置中间件，使得每次请求都来校验token 12345678910const koajwt = require('koa-jwt')// 密钥const jwtSecret = 09876app.use(koajwt(&#123; secret: jwtSecret&#125;).unless(&#123; // 表示users/register, users/login 不做token验证 path: [/^\/users\/register/,/^\/users\/login/]&#125;)); 生成token在login接口处使用jwt的sign 方法 生成token 123456789101112131415161718192021222324252627282930313233343536373839404142const jwt = require('jsonwebtoken')// 注意，这个地方的密钥和app.js中的一样const jwtSecret = 09876// token的过期时间const expireTime = '10s'const login = async function (ctx, next) &#123; const req = ctx.request.body; if (!req.mobile || !req.password) &#123; ctx.body = &#123; code: -1, desc: '手机号或者密码不能为空' &#125; &#125; else &#123; const data = await user.find(req.mobile) if (data) &#123; if (data.password === req.password) &#123; // 生成token,接受三个参数： 1 存储在token中的数据，2 密钥， 3 option。设置过期时间 const token = jwt.sign(&#123; mobile: req.mobile, passWord: req.password &#125;, jwtSecret, &#123; expiresIn: expireTime &#125;) ctx.body = &#123; code: 0, desc: '登录成功', data: &#123; token: token // 生成token 后将其返回 &#125; &#125; &#125; else &#123; ctx.body = &#123; code: -1, desc: '密码错误' &#125; &#125; &#125; else &#123; ctx.body = &#123; code: -1, desc: '未注册' &#125; &#125; &#125;&#125; 验证token我们写一个接口getUserInfo来验证token是否可用1234567891011121314151617181920212223242526const getUserInfo = function (ctx, next) &#123; const req = ctx.request.body // 一般情况下token 是通过header来传递的 const token = ctx.header.authorization // 解析token const result = await tool.verifyToken(token); // result 就是用户登录时存到jsonwebtoken中的登录信息 // 拿这个里面的信息去查数据库，取到用户的基本信息 const data = await user.find(req.mobile) ctx.body = &#123; code: 0, desc: '获取用户信息成功', data: data &#125;&#125;// tool.js的 verifyToken 方法const getToken = require('jsonwebtoken')// 注意，这个地方的密钥和app.js中的一样const jwtSecret = 09876const verifyToken = function (token) &#123; return new Promise((reslove, reject) =&gt; &#123; const info = getToken.verify(token.split(' ')[1], jwtSecret); reslove(info); &#125;)&#125; 总结 上面就是jswonwebtoken的全部使用流程，希望可以帮助到你。谢谢]]></content>
      <tags>
        <tag>nodejs, koa2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日算法]]></title>
    <url>%2F2020%2F01%2F09%2F%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 判断一个数是否为素数Math.pow(N, 2)&lt; n &lt; Math.pow(N+1, 2) 123456789101112function is_Prime(n) &#123; if (n &lt;= 0) return false; let N = Math.floor(Math.sqrt(n)); let is_prime = true; for(let i = 0; i &lt;= N; i++) &#123; if (n % i === 0) &#123; is_prime = false; break; &#125; &#125; return is_prime;&#125; 2. 是否有对应的括号, [[]] 返回true， [(()] 返回false;用栈的数据结构去解 12345678910111213141516function is_balance(str) &#123; let [first, ...others] = str; let arr = [first]; if (others.length === 0) return false; for(let i = 0; i &lt; others.length; i++) &#123; if (match(arr[arr.length - 1], others[i])) &#123; arr.pop(); &#125; else &#123; arr.push(others[i]); &#125; &#125; return arr.length === 0; function match(m, n) &#123; return (m === '[' &amp;&amp; n === ']') || (m === '(' &amp;&amp; n === ')') &#125;&#125; 3. 输入 3[a]2[b]2[c], 输出 aaabbcc1234567891011121314151617181920212223function printStr(str) &#123; let [first, ...others] = str; let arr = [first]; let temp = ''; for (let i = 0; i &lt; others.length; i++) &#123; if (/\w/.test(others[i]) || /\d/.test(others[i])) &#123; arr.push(others[i]); &#125; &#125; for (let m = 0; m &lt; arr.length; m++) &#123; if (/\d/.test(arr[m])) &#123; temp = temp + printLetter(arr[m], arr[m + 1]); &#125; &#125; return temp; function printLetter(num, letter) &#123; var s = ''; for (let j = 0; j &lt; num; j++) &#123; s = s + letter; &#125;; return s; &#125;&#125; 4. 多维数组 转 一维数组 数组中有3则删除，有两个3，将数组清空123456789101112131415161718var tempArr = [];function flattenPlus(arr) &#123; var i = 0; for (let i = 0; i &lt; arr.length; i++) &#123; if (Array.isArray(arr[i])) &#123; flattenPlus(arr[i]); &#125; else if (arr[i] === 3)&#123; i++; if (i &gt;= 2) &#123; tempArr.push([]); break; &#125; &#125; else &#123; tempArr.push(arr[i]); &#125; &#125;&#125; 5. apply 或者 call 实现bind12345678Function.prototype.bind = function(context) &#123; var self = this; // 去掉第一个参数后的所有参数，因为第一个参数传的是context var args = [].slice.call(arguments, 1); return function() &#123; return self.apply(context, args.concat([].slice.call(arguments))); &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter 学习笔记（一）]]></title>
    <url>%2F2019%2F07%2F10%2FFlutter-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Flutter 的两个抽象类 Flutter 分为 StatelessWidget 和 StatefulWidget 两个抽象类，为我们提供自定义组件.StatelessWidget 是无状态控件， 即不可变状态的控件,通过构建其他控件来描述用户界面的一部分。StatefulWidget 是有状态控件，可以定义一个具有可变状态的控件。实现一个 stateful widget 至少需要两个类：（1）一个 StatefulWidget 类；（2）一个 State 类，StatefulWidget 类本身是不变的，但是 State 类在 widget 生命周期中始终存在。 举例说明：官网的例子实现一个随机变化的英文字符串 先创建一个最简单的 state 类,然后重写build 方法，返回随机字符串 1234567class RandomWordsState extends State&lt;RandomWords&gt; &#123; @override Widget build(BuildContext context) &#123; final wordPair = WordPair.random(); return Text(wordPair.asPascalCase); &#125;&#125; 添加有状态的RandomWords widget 1234class RandomWords extends StatefulWidget &#123; @override RandomWordsState createState() =&gt; RandomWordsState();&#125; 在 StatelessWidget 中写界面显示 1234567891011121314class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &apos;Welcome to Flutter&apos;, home: Scaffold( title: Text(&apos;Welcome to Flutter&apos;), body: Center( child: RandomWords() ) ) ) &#125;&#125; 重启应用。应用应该像之前一样运行，每次热重载或保存应用程序时都会显示一个单词对 Flutter 使用外部package举例说明： 添加english_words软件包 在pubspec.yaml 中，将 english_words（3.1.0或更高版本）添加到依赖项列表 12345 dependencies: flutter: sdk: flutter cupertino_icons: ^0.1.2 + english_words: ^3.1.0 在 Android Studio 的编辑器视图中查看 pubspec 时，单击右上角的 Packages get，这会将依赖包安装到你的项目。或者在终端输入 1flutter pub get 在lib/main.dart中引入, 1import &apos;package:english_words/english_words.dart&apos; 总结pubspec.yaml 管理Flutter 应用程序的assets(资源，如图片、package等), 个人暂且理解为package.json, 如果不对欢迎指正。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flutter 学习笔记（二）]]></title>
    <url>%2F2019%2F07%2F10%2FFlutter-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Flutter 的安装由于我用的是mac 电脑，于是就按照官网上的mac安装方法一步一步安装。 第一步：下载并解压flutter的安装包网址： https://flutter.dev/docs/get-started/install/macos 第二步： 配置环境变量在根目录下找到.base_profile文件，或者直接打开终端，输入：12345vim ~/.bash_profile``` 然后在打开的文件中（如果没有此文件，则是新建文件），加入以下一行代码：```codeexport PATH='$PATH: Users/XXX/flutter/bin' 提示： 上面的路径要写你第一步中解压后的flutter的路径。这一点很重要哦 然后执行下面的命令，使环境变量生效：1source ~/.bash_profile 然后试试看成功了没：1flutter -h 如果有flutter的相关帮助信息输出，则说明环境变量配置成功至此，环境变量安装完成。 第三步： 安装flutter所需要的开发环境执行以下命令来检查当前开发环境：1flutter doctor 按照上面的提示，一步一步在终端执行]]></content>
  </entry>
  <entry>
    <title><![CDATA[mongoDB的安装]]></title>
    <url>%2F2019%2F04%2F22%2FmongoDB%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[第一步：下载打开https://www.mongodb.com/download-center， 选择servertab选项，会根据你的电脑显示下载包。点击Download. 第二部：安装将下载下来 的包解压，然后放到/usr/local/目录下（MAC电脑）。不知道如何打开/usr/local，打开Finder, 按快捷键command + shift + G,然后输入/usr/local,点击前往文件夹。把解压下来的mongodb的包拷贝到local目录下,此时的mongoDb的地址应该是/usr/local/mongodb/bin。 第三部：更换目录如果不想用根目录的data/db中存数据库，可以自定义数据库的存储目录。在目录/usr/local/mongodb/bin中执行./mongodb -dbpath &#39;你的目录&#39;。目录一定要加引号，不然不会生效。 第四部： 启动在目录/usr/local/mongodb/bin中 执行./mongod来启动，然后再启动一个终端，在目录/usr/local/mongodb/bin中 执行./mongo来连接。然后在浏览器中输入：http://localhost:27017/, 看到页面中输出 ‘It looks like you are trying to access MongoDB over HTTP on the native driver port.’。就说明启动成功了。 mongo 命令学习首先在终端输入mongo,进行数据库的连接。然后输入show dbs查看当前的数据库， 比如use test,使用一个test 数据库。 查询命令db.collections.find() 查询名字为collections的集合 下的所有数据。db.collections.find().count() 查询数据量 db.collections.find({name: &#39;zj&#39;}) 按条件查询db.collections.find().limit(10) 查询前10条数据db.collections.find().skip(10).limit(10) 查询第 11条至 第20条数据db.collections.find({num: {$gt: 10}}) 查询 大于 10的数据db.collections.find({num: {$gte: 10}}) 查询 大于等于 10 的数据db.collections.find({num: {$lt: 10}}) 查询 小于 10 的数据db.collections.find({num: {$lte: 10}}) 查询小于等于 10 的数据 db.collections.find().sort({num: 1}) 查询出来的数据按 num 进行升序排列，如果 num: -1 则为降序db.collections.find({}, {name: 1}) 查询出来的结果只显示姓名，如果不想显示id: 则在后面加上：id: 0 插入命令db.collections.insert({name: &#39;zj&#39;}) 向集合中插入一个数据 删除命令db.collections.remove({name: &#39;zj&#39;}) 删除集合中的某个数据db.collections.remove({}) 删除集合中的所有数据 更新命令db.collections.update({name: &#39;zj&#39;}, {$set: {age: 1}}) 更新集合中某条数据，为这条数据增加一个属性db.collections.update({name: &#39;zj&#39;}, {$set: {movies: [&#39;hh&#39;, &#39;nn&#39;, &#39;ll&#39;]}}) 为这条数据设置一个属性，属性值是一个数组db.collections.update({name: &#39;zj&#39;}, {$push: {&#39;movies&#39;: &#39;mm&#39;}}) 为这个数据的属性中新增一个值db.collections.update({name: &#39;zj&#39;}, {$inc: {&#39;sal&#39;: 100}}) 意思是在原有值上增加100， $des在原有值上 减少一百 db.collections.replaceOne({name: &#39;zj&#39;}, {name: &#39;hahahah&#39;}) 将名字为’zj’的这条数据替换为 {name: ‘hahahah’} db.collections.update({name: &#39;zj&#39;}, {$unset: {age: 12}}) 把这条数据中的 age 属性删除, age的值可以随意写]]></content>
      <tags>
        <tag>mongoDb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ajax的跨域请求之预检请求]]></title>
    <url>%2F2019%2F04%2F21%2F%E5%85%B3%E4%BA%8Eajax%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E4%B9%8B%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[请求服务器，浏览器返回 OPTIONS上周在一个项目中，我打算把token和用户id,通过http协议的header传递给后台，这样比较安全一些。可是我设置完header后，请求后台时，后台给我报了400，提示跨域请求了。我在method的方法中看到并不是我传的GET方法，而是一个OPTION. 跨域请求的简单请求与非简单请求于是在网上搜了一下，找到了原因。原来跨域的时候，浏览器发起的请求分为简单请求和非简单请求。 简单请求参考链接 使用下列方法之一： GET HEAD POST Fetch 规范定义了对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段。该集合为： Accept Accept-Language Content-Language Content-Type （需要注意额外的限制） DPR Downlink Save-Data Viewport-Width Width Content-Type 的值仅限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded 请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。 请求中没有使用 ReadableStream 对象 所以这样来看，我之前只是简单的通过GET方法向后台请求，后台设置 Access-Control-Allow-Origin: * 就可以连通了。但是我这次是设置了自定义的header,没有符合上述简单请求的条件，所以是无法连接上的。 非简单请求 使用了下面任意一种HTTP 方法： PUT DELETE CONNECT OPTIONS TRACE PATCH 人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为： Accept Accept-Language Content-Language Content-Type (需要注意额外的限制) DPR Downlink Save-Data Viewport-Width Width Content-Type 的值不属于下列之一: application/x-www-form-urlencoded multipart/form-data text/plain其实说明白了，也就是简单请求的反面，就是非简单请求。非简单请求需要在正式与服务器建立连接之前发送一个预检请求，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。这个预检请求就是先向服务器发送了一个METHOD 为 OPTION的方法。我在axios中使用了headers{ userid: params(&#39;userid&#39;)}，即自定义了header,触发了预检请求，所以就向服务器发送了OPTION 方法。服务器那里可能不接受我的请求，所以返回了400。 我问了后台同事了解情况，他们那里是之前封装的统一方法，不认识 OPTION方法，所以给我返回了 400。 解决方法经过协调， 后台在代码中加入以下片段，就可以调通了12345if (&quot;OPTIONS&quot;.equals(request.getMethod()))&#123;//这里通过判断请求的方法，判断此次是否是预检请求，如果是，立即返回一个204状态吗，标示，允许跨域；预检后，正式请求，这个方法参数就是我们设置的post了 response.setStatus(HttpStatus.SC_NO_CONTENT); //HttpStatus.SC_NO_CONTENT = 204 response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, DELETE, OPTIONS, DELETE&quot;);//当判定为预检请求后，设定允许请求的方法 response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type, x-requested-with, Token&quot;); //当判定为预检请求后，设定允许请求的头部类型 response.addHeader(&quot;Access-Control-Max-Age&quot;, &quot;1&quot;); 最后终于调通了。以上代码来自cors跨域之简单请求与预检请求（发送请求头带令牌token）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ajax跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 优化打包时间]]></title>
    <url>%2F2019%2F04%2F18%2Fwebpack-%E4%BC%98%E5%8C%96%E6%89%93%E5%8C%85%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[随着项目业务越来越多，引入的包就越来越多，发现项目的打包时间太长了，需要优化一下。网上搜到的那行方法，基本上在项目中都做了。项目是react, 用的antd,也使用了按需引入。后来看到一个autodll-webpack-plugin的插件，觉得很有效。是结合了之前的DLLPlugin和DLLReferencePlugin实现自动整合，插入html，非常方便。话不多说，开始搞起。 autodll-webpack-plugin 的作用是什么？在webpack打包时，对于第三方依赖的库，比如Vue,vuex,vue-router,react,react-dom等这些不会更改的依赖。webpack 也都会默认的进行打包，然后加到html中。这个是比较浪费的，因为我们只需要对更改的文件进行打包，未更改的依赖直接加到html上就好。 autodll-webpack-plugin的作用就是让依赖代码和常常修改的代码分开打包，每次更改我的代码后，webpack只需要打包我更改的代码，对于第三方依赖，只在第一次打包的时候打包一次，以后都不会再打包，这样来减少打包时长。 其实最早用此方法的是DLLPlugin 和 DLLReferencePlugin。只不过这俩用起来不太自动化，需要一些手动配置。所以我就想一步到位，使用autodll-webpack-plugin 自动整合。 autodll-webpack-plugin的使用autodll-webpack-plugin webpack 4下，执行：1npm install --save autodll-webpack-plugin webpack 2 / 3下，执行：1npm install --save autodll-webpack-plugin 接着在你的webpack.config.prod.js中引入如下代码：（怎样在react中找到wepback的配置文件，自行搜索）12345678910111213141516171819202122const AutoDllPlugin = require(&apos;autodll-webpack-plugin&apos;); plugins: [ new HtmlWebpackPlugin(&#123; inject: true, // will inject the main bundle to index.html template: &apos;./src/index.html&apos;, &#125;), new AutoDllPlugin(&#123; inject: true, // 将会自动注入dll到index.html debug: true, // 会在控制台看到执行 filename: &apos;[name]_[hash].js&apos;, path: &apos;./dll&apos;, // 编译出来的存放目录。 entry: &#123; vendor: [ // 这里面写你不需要多次打包的依赖库 &apos;react&apos;, &apos;react-dom&apos;, &apos;lodash&apos; ] &#125; &#125;) ] 注意： 如果你不想手动把第三方依赖的库加入html的话，配合html-webpack-plugin一起使用，可以自动将js加入html.我就是采用的这个方法。可是坑也就是在这里埋下的。 坑来了，猝不及防准备就绪之后，我开始执行npm run build。build命令执行之后，可以看到我的编译时间可以说是缩小了一半，太厉害了！build文件夹下也有dll文件夹,里面是我打包进去的vendor.xxx.js。 但是我打开index.html查看，却没有发现有script标签的源文件是dll/vendor.xxx.js的。我刚开始以为是路径写的不对，开始修改路径。可是越改越乱。无论我怎么改就是不行。 找原因。既然是往html中注入，那就肯定和html-webpack-plugin有关。一步一步来。我先按照github上给的demo，在本地运行一下，看看这个功能是否可行。 执行完这个例子，确实是可以的。那为什么我的项目就不可以？来看看例子上的html-webpack-plugin版本号 再看我项目上用的html-webpack-plugin版本号 两个版本对不上。 运行autodll-webpack-plugin给出打demo，在src/plugins里面进行信息打印，是有输出的。 但是在我的项目中这个地方出来的却是undefined。原因找到了，html-webpack-plugin3.0版本用api的是htmlWebpackPluginBeforeHtmlGeneration,但是在4.0.0版本里面缺没有找到这个api。 解决方法：在html-webpack-plugin 4.0.0版本里找到了与此htmlWebpackPluginBeforeHtmlGeneration相同的apibeforeAssetTagGeneration。于是就开始更改autodll-webpack-plugin中的lib/plugins.js文件。具体更改如下：要先引入 4.0.0的html-webpack-plugin1var HtmlWebpackPlugin = require(&apos;../../react-scripts/node_modules/html-webpack-plugin&apos;); 然后更换新的api1234567compiler.hooks.compilation.tap(&apos;AutoDllPlugin&apos;, function (compilation) &#123; if (!HtmlWebpackPlugin.getHooks(compilation).beforeAssetTagGeneration) &#123; return; &#125; HtmlWebpackPlugin.getHooks(compilation).beforeAssetTagGeneration.tapAsync(&apos;AutoDllPlugin&apos;, doCompilation); &#125;); 然后执行 yarn build 可以看到，已经自动加到index.html中了。完成！]]></content>
      <categories>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo 博客网站搭建记录]]></title>
    <url>%2F2019%2F04%2F13%2Fhello%2F</url>
    <content type="text"><![CDATA[hexo 写作1$ hexo new [layout] &lt;title&gt; [layout]是指布局，一般用post; hexo 热更新1$ hexo s -g --debug 支持热更新，修改配置文件后刷新一下可以看到即时效果 但如果修改了 post，则需要重新运行一下。（命令中 g 是 generate 的缩写，s 是 sever 的缩写） hexo 更改主题 在https://hexo.io/themes/找到喜欢的主题 使用git clone 下喜欢的主题 克隆后，找到_config.yml文件中的theme,将名称改为主题名称即可 hexo 发到github pages 上时遇到的坑（1） 执行hexo deploy后， 总是收到邮件 pages build failed。回到github 上本仓库的setting,可以看到‘ The tag fancybox on line 77 in themes/landscape/’ 报了这个错误。 根本原因是 hexo 的默认主题 landscape 中的readme.md中一些描述不符合github pages 中的一些规定， 把这个readme.md 删掉就可以了。 （2）执行了hexo deploy后，我以为就完事了，打开我的https://zhangjiana.github.io/myBlob/页面后，发现啥也没有。 在网上搜了一下。在_config.yml中最下面的deploy中，加上branch: master。 重新部署就可以了。官网上说的是默认会知道当前的分支，不用指定，可我发现还是指定了才能打开博客页面。 hexo 打开阅读全文Hexo 的 Next 主题默认是首页显示你每篇文章的全文内容，但这会使你的首页篇幅过于冗长。在theme/next目录下的_config.yml中，找到下面代码，改为ture即可。123auto_excerpt: enable: false length: 150 hexo 加入阅读次数 打开leancloud官网 https://leancloud.cn，注册一个账号。然后创建一个class 为 Counter的类，然后在heme/next目录下的_config.yml中，找到leancloud_visitors，把你的appid 和appkey填进去，重新启动就可以了。 最后 大功告成，一直都想拥有一个自己的博客网站。到今天才算是正式有了一个博客，莫名的开心。以后我会好好记录工作中遇到的技术难题，分享我的踩坑日常。敬请期待！]]></content>
      <categories>
        <category>hexo博客</category>
      </categories>
  </entry>
</search>
